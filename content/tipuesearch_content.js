var tipuesearch = {"pages": [{'title': 'About', 'text': '\n 個人倉儲 \n 個人網站 \n 個人簡報 \n 個人網誌 \n 分組網站 stage1-ag2 \n 分組網站 stage2-ag2 \n 分組網站 stage3-ag2 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Weeks', 'text': 'Week1 \n Week2~4 \n Week5~9 \n Week10~18 \n', 'tags': '', 'url': 'Weeks.html'}, {'title': 'Week1', 'text': 'Week1 \n 建立個人倉儲cd2021 \n \n 1.下載kmol2021_spring_v2.7z，完成後開啟。 \n 2.登入個人github帳號，使用老師的子模組創建新的倉儲cd2021。 \n 3.進入tmp。 \n 4.輸入git clone --recurse-submodules https://github.com/40623121/cd2021.git 取得子模組資料。 \n 5.完成後，進入cmsimde資料夾輸入python wsgi.py開始編輯倉儲。 \n 6.於瀏覽器輸入https://localhost:9443/ \n 7. 編輯完成後，輸入git status檢查 \xa0 -> \xa0 git add .全部新增 \xa0 -> \xa0 git commit -m "項目名稱" \xa0 -> \xa0 git push推送。\xa0 \xa0 \n \n \n \n 從英文單字解釋了解何謂協同? 產品? 設計? 以及實習? \n \n Collaborative 協同 \n 涉及兩個或多個為特殊目的而一起工作的人。 \n Product\xa0 產品 \n 為出售而製造或精製的物品或物質。 \n Design 設計 \n 為某物制定或繪製計畫。 \n Practice 練習 \n 實際去行動而不是單純去想或觀念。 \n \n 編輯\xa0Leo Editor \n 1.於Y槽中輸入leo \n 2.若不想為黑色，打開pelican.leo \n 3.要更改blog內容使用pelican.leo，要更改簡報內容使用reveal.leo \n 4.要創建同一格的目錄按Ctrl+I，向右移按Ctrl+R \n \n 遇到的問題  :\xa0 \n 1.有在leo editer更改，但是推送完遠端並沒有改變(已解決，沒有更改DISQUS_SITENAME及SITEURL) \n 2.打開leo時進入一個無限迴圈(已解決，建立一個.leoID字串) \n \n 建立.leoID.txt \n 針對 Leo Editor 6.3 在 Windows 10 無法正確建立 home/.leo/.leoID.txt，且打開leo會產生一個無限迴圈，所以要在home_ipv6創建一個.leo資料夾，並新增一個有隨意字串的.leoID.txt檔。 \n \n \n', 'tags': '', 'url': 'Week1.html'}, {'title': 'Week2~4', 'text': '', 'tags': '', 'url': 'Week2~4.html'}, {'title': 'Week2', 'text': '第一階段分組協同實習 \n 制定組序 \n 動機 :\xa0 進行各班制定組序過程中, 發現即便採用 Ethercalc 以網際協同方式同步讓各班自選組員填入兩兩成組的學員學號, 但仍缺人工或自動定各班組序的有效方案，所以要說明自己認為最有效率的第一階段與訂定組序的方法及流程。 \n 人工 : 在教室前面的其中一台電腦做一個excel表單，並派班代負責key資料，找好組員的人派其中一個代表去報學號，key完後依序排組序下來，這樣不僅不會出錯，組序也不會亂掉。 \n \n 繪製零件 \n 先在A4白紙設計各個零件尺寸，使用Onshape&Inventor畫出並組合。 \n \n \n \n 熟悉CoppeliaSim \n 做一個基本四輪車並以鍵盤控制四輪車 \n \n 遇到的問題  :\xa0 \n 1.車子跑得很慢 (已解決，增加Target velocity的大小) \n 2.程式碼代入車子本身後跑不動 (已解決，在更改馬達名字時打錯) \n \n \n', 'tags': '', 'url': 'Week2.html'}, {'title': 'Week3', 'text': '\n 製作分組專題 \n 標題 : 2021-協同產品實習- stage1-ag2 專題題目 : 飛機起降 動機 : 對設計路徑類的東西有興趣 \n 網站 :  分組網站 \n \n 分組協同網站同步 \n \n 當 stage1 兩人一組進行協同時, 要讓各組員 Github 帳號下都帶有分組倉儲與分組網站, 則可以透過 git remote add, 設法讓各組員 Github 帳號下的分組網站內容同步。 \n 操作步驟 :\xa0 \n 1.另一個組員設立一個沒有東西的倉儲(名字需要一樣) \n 2.取得子模組資料後，輸入git remote add xxx\xa0 https://github.com/另一個組員學號/倉儲名稱.git \n 3.從另一個組員的setting寄從另一個組員的setting > Manage access寄邀請給自己 \n 4.git push xxx，即完成。 \n \n 遇到的問題  : \n 1.推送後顯示 remote: Permission (已解決，尚未從gmail確認對方的invite) \n \n \n update cmsimde \n \n \n 1. init.py :\xa0 其中的 site_title, ip 與 port 可以讓使用者自行修改, site_title 是網站標題, ip 為動態網站啟動時所使用的網路位址, 可設為內部或外部 IPv4 (IPv6), port 則是動態網站啟動時所佔用的埠號 \n 2. http-server.py :\xa0 執行後會使用內建的 localhost 與 port 8444 伺服 content 子目錄中的 CMSiMDE 靜態網頁 \n 3. cms.bat \xa0: \xa0讓使用者執行動態網站用的批次檔案 \n 4. acp.bat \xa0: \xa0如果已經將倉儲設為 ssh 連線, 且提供遠端與近端的認證模式, 就可以使用 acp "字串" 代替執行 git add ., git commit -m "提交訊息", 以及 git push 三個指令。 \n \n 遇到的問題  :\xa0 \n 1.推送後遠端沒有推送成功，且gmail顯示Page build failure(已解決，cmsimde錯誤，在cmsimde目錄下輸入git checkout 自己的分支即可。) \n 確認分支方式 \n \n 2.wsgi.py打不開，顯示context.load_cert_chain(\'localhost.crt\' . \'localhost.key\')(已解決，將倉儲的兩個對應檔案複製進cmsimde目錄下即可。) \n \n \n 以ssh對Github連線 \n \n 操作步驟 :\xa0 \n 1.打開start_ipv6.bat 2.輸入sh及ssh-keygen -t rsa -b 4096 -C "使學號"產生key，打上key的產生區域。 3.利用 puttygen.exe 將上述建立的 Openssh keys 轉為 putty 可以辨識的格式。 4.修改啟動的 start.bat 加入下列設定: \xa0 \xa0 \xa0 \xa0set GIT_HOME=%Disk%:\\portablegit\\bin\\ \xa0 \xa0 \xa0 \xa0set GIT_SSH=%Disk%:\\putty\\plink.exe 修改完成後,重新啟動。 5.將要使用 ssh 連線的倉儲 .git 中的 config 檔案中的 url 設定改為 ssh 連線格式:url = git@github.com:倉儲名稱/cd2021.git。 6.開啟 putty.exe 建立一個 session 名稱為 github.com, 其中指定 Connection > Proxy 與 Connection > SSH > Auth。 7.將下列字串加入SciTE並存儲到\\.ssh\\config Host github.com \xa0 \xa0 User git \xa0 \xa0 Port 22 \xa0 \xa0 Hostname github.com \xa0 \xa0 TCPKeepAlive yes \xa0 \xa0 IdentitiesOnly yes 8.將所建立的OpenSSH格式的public key內容,加進自己的Github帳號SSH settings中。 \n 遇到的問題  : \n 1.putty顯示Network error: Connection refused(已解決，proxy設定錯誤) \n \n', 'tags': '', 'url': 'Week3.html'}, {'title': 'Week4', 'text': '報 告 週 \n youtube :\xa0 \n \n PDF :\xa0 \n pdf \n \n 文獻探討 \n 分組題目的選定 \n 準備開始 W5-W9 (5 Weeks) 四人一組的分組專題。 \n \n', 'tags': '', 'url': 'Week4.html'}, {'title': 'Week5~9', 'text': '', 'tags': '', 'url': 'Week5~9.html'}, {'title': 'Week5', 'text': '排序各組簡報檔案 \n python count mp4 time \n 製作分組專案 \n 標題 : 2021-協同產品實習- stage2-ag2 \n 專題題目 :\xa0變速機構\xa0Transmission mechanism \n 動機 :\xa0由於這幾年各國經濟起飛家家戶戶都賺的盆滿鍋滿，有了錢就想要消費，於是想到有錢人都會買車，於是每個家庭必備了一台車，所以汽車業蓬勃發展，各個國家在汽車市場，都想要分杯羹。 然而台灣的汽車業有如剛出生的小羊，嗷嗷待哺一般，剛踏入市場，引擎跟人買，變速箱跟人拿，車架跟人借 所以為了能幫助台灣汽車業蒸蒸日上，所以我們決定全車由我們台灣人自己設計製造，但想要一步登天，將全車在這短短的一個月內設計出來有如癩蛤蟆想吃天鵝肉，所以這次協同產品設計，我們決定先設計汽車中至關重要的變速箱系統。 想要在換檔的時候不會有太大的震動，想要在起跑上贏過別人，想要在尾速速度可以繼續延伸，現在我們就來設計出台灣特有的變速箱，讓世界看見台灣!!! \n 網站 :  分組網站 \n 分組專案設計與簡報重點 \n 1.在沒有實體原型製造情況下，產出自我驗證的結果。 \n 2.設計流程以理論分析或文獻參考佐證，凸顯選定題目或結果的重要性。 \n 3.善用What、Why、When、Who、How、Where? \n 4.簡報以Web based投影片為主，方便參閱，內容要呈現重點，且文句要仔細校正。 \n \n 繪製專案構想圖 \n \n \n \n 參考文獻 \n 參考的網站與資料 \n 參考資料 1 \n 參考資料 2 \n \n', 'tags': '', 'url': 'Week5.html'}, {'title': 'Week6', 'text': '繪製零件與組合圖 \n \n \n \n Solvespace \n \n', 'tags': '', 'url': 'Week6.html'}, {'title': 'Week7', 'text': '\n 作動影片 \n 設定好軸的轉速後，調整好從屬關係及碰撞關係後就能模擬出空檔的作動了。 \n \n \xa0 \n', 'tags': '', 'url': 'Week7.html'}, {'title': 'Week8', 'text': "製作路徑 \n 給予打檔桿路徑及dummy後，將關節設定成IK模式，並新增IK group和IK element， 程式碼是設定target跟隨path運動，運動速度為0.02。 \n function sysCall_threadmain()\n    dummy_handle = sim.getObjectHandle('Target')\n    path_handle = sim.getObjectHandle('Path')\n    print('start follow path')\n    sim.followPath(dummy_handle, path_handle, 1, 0, 0.02, 1)\nend \n \n \n \n Inventor版 \n \n", 'tags': '', 'url': 'Week8.html'}, {'title': 'Week9', 'text': '報告週 \n Youtube :\xa0 \n \n PDF :\xa0 \n pdf \n \n', 'tags': '', 'url': 'Week9.html'}, {'title': 'Week10~18', 'text': '', 'tags': '', 'url': 'Week10~18.html'}, {'title': 'Week10', 'text': '開始分組專題製作 \n 先瞭解各個組員是否會使用SSH等一些基本的東西，並且建立好分組網站及確認組員都熟悉協同方式。 \n 標題 : 2021-協同產品實習- stage3-ag2 \n 專題題目 :  機械停車塔\xa0Mechanical parking tower \n 設計理念 :\xa0於世界人口逐漸增多且寸土寸金，在都市區域租車位都需要碰運氣，有錢也不一定能租到，所以我們就想設計一個可以將大量的車輛容納於一個樓層，不僅可以減少使用地還可以集中管理車輛；因為是自動化的，也能減少人力的消耗。 \n 網站 : \xa0 分組網站 \n', 'tags': '', 'url': 'Week10.html'}, {'title': 'Week11', 'text': 'w11直播 \n stage3-ag2-40623121 主題 : 討論要做的項目及選定 \n \n 題目選定 \n 最後選定題目為 停車塔 ，不延續各自組別stage-ag1,stage-ag2的題目。 \n 協同推送 \n 因為組別人數由4人增加到了8人，如果用一樣的方式慢慢一個一個git push 學號至每個人的倉儲要推送7次，所以就異想天開的想一次推完，後來經過幾次測試後也成功了，如下圖。 \n \n 而原理其實也很簡單，就是將每個remote的內容合在同一個底下而已，這樣也不怕有漏推的問題了，要使用的話進去.git資料夾裡的config更改就好了。 \n [remote "all"]\n    url = git@github.com:40823101/stage3-ag2.git\n    url = git@github.com:40823102/stage3-ag2.git\n    url = git@github.com:40823104/stage3-ag2.git\n    url = git@github.com:40823106/stage3-ag2.git\n    url = git@github.com:40823151/stage3-ag2.git\n    url = git@github.com:40871106/stage3-ag2.git\n    fetch = +refs/heads/*:refs/remotes/40823101/*\n    fetch = +refs/heads/*:refs/remotes/40823102/*\n    fetch = +refs/heads/*:refs/remotes/40823104/*\n    fetch = +refs/heads/*:refs/remotes/40823106/*\n    fetch = +refs/heads/*:refs/remotes/40871106/*\n    fetch = +refs/heads/*:refs/remotes/40823151/*\n \n \n', 'tags': '', 'url': 'Week11.html'}, {'title': 'Week12', 'text': 'Task1  :\xa0 \n 讀取 \xa0 stage3_2a.txt , 建立 Stage3 的分組倉儲, 分組網頁, 以及各組員倉儲及網頁連結. \n 程式碼 :\xa0 \n with open("stage3_2a.txt") as fh:\n   #先將我們存起來stage3_2a.txt打開並命名為fh\n    data = fh.readlines()\n    #將stage3_2a.txt的資料以串列形式存為data\nfor i in range(6):\n    #將次數限定就不會告知list index out of range了\n    newdata1 = data[i].replace(\'4823122\',\'40823122\')\n    #因為40823122的學號打錯了,所以用 replace 把舊的替換成新的\n    newdata2 = newdata1.replace(\'\\t\\t\',\'\')\n    #因為有一組只有6人,所以用 replace 把空位刪除\n    newdata3 = newdata2.replace(\'_\',\'-\')\n    #因為在編輯txt的時候-會變成_,所以用 replace 把_修正為-\n    group = newdata3.rstrip("\\n").split("\\t")\n    #先取出newdata list中的第i項,消除元素中/n,再以\\t取出需要的文字\n    print(\'<p><a href="https://github.com/\'+group[1]+\'/\'+group[0]+\'">\'+group[0]+\' repo</a> | <a href="https://\'+group[2]+\'.github.io/\'+group[0]+\'">\'+group[0]+\' site</a></p>\')\n    for j in range(1,18,2):\n    #設一個範圍,(1到18,每次+2,1<=j<18)\n        try:\n            n = group[j].replace(\'40823112\',\'a40823112\')\n            #因為40823112的github帳號是a40823112,所以用 replace 把帳號修正\n            print(\'<p>\'+\'<a href="https://github.com/\'+n+\'/cd2021">\'+group[j]+\' repo</a> | <a href="https://\'+n+\'.github.io/cd2021">\'+group[j]+\' site</a></p>\')\n        except:\n           continue\n        #這邊使用try.....except,因為有一組6個人,導致有空格,所以需要用continue讓迴圈繼續跑 \n \n 操作影片 :  \n \n \n Task2  :\xa0 \n 下載\xa0 CoppeliaSim 4.2.0 載點 \n 下載控制程式碼 remote API 來控制場景 \n \xa0 http://mde.tw/cad2020/downloads/coppeliasim/vrep_remoteapi_ex.7z \n 把程式碼放進SciTE後GO \n 程式碼 :\xa0 \n import sim as vrep\nimport math\nimport random\nimport time\n \nprint (\'Start\')\n \n# Close eventual old connections\nvrep.simxFinish(-1)\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'192.168.192.1\', 19997, True, True, 5000, 5)\n \nif clientID != -1:\n    print (\'Connected to remote API server\')\n \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "teacher",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n    # Communication operating mode with the remote API : wait for its answer before continuing (blocking mode)\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiConstants.htm\n    opmode = vrep.simx_opmode_oneshot_wait\n \n    # Try to retrieve motors and robot handlers\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectHandle\n    ret1, wristHandle = vrep.simxGetObjectHandle(clientID, "WristMotor", opmode)\n    ret2, elbowHandle = vrep.simxGetObjectHandle(clientID, "ElbowMotor", opmode)\n    ret3, shoulderHandle = vrep.simxGetObjectHandle(clientID, "ShoulderMotor", opmode)\n    ret4, robotHandle = vrep.simxGetObjectHandle(clientID, "2W1A", opmode)\n \n    # If handlers are OK, execute three random simulations\n    if ret1 == 0 and ret2 == 0 and ret3 == 0:\n        random.seed()\n        for i in range(0, 3):\n            # Start the simulation\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxStartSimulation\n            vrep.simxStartSimulation(clientID, opmode)\n            print("----- Simulation started -----")\n \n            # Start getting the robot position\n            # Unlike other commands, we will use a streaming operating mode\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectPosition\n            pret, robotPos = vrep.simxGetObjectPosition(clientID, robotHandle, -1, vrep.simx_opmode_streaming)\n            print("2w1a position: (x = " + str(robotPos[0]) +\\\n                  ", y = " + str(robotPos[1]) + ")")\n \n            # Start getting the robot orientation\n            # Unlike other commands, we will use a streaming operating mode\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectOrientation\n            oret, robotOrient = vrep.simxGetObjectOrientation(clientID, robotHandle, -1, vrep.simx_opmode_streaming)\n            print("2w1a orientation: (x = " + str(robotOrient[0]) + \\\n                  ", y = " + str(robotOrient[1]) +\\\n                  ", z = " + str(robotOrient[2]) + ")")\n \n            # Make the robot move randomly five times\n            for j in range(0, 5):\n                # Generating random positions for the motors\n                awrist = random.randint(0, 300)\n                aelbow = random.randint(0, 300)\n                ashoulder = random.randint(0, 300)\n \n                # The control functions use Radians to determine the target position.\n                # Here, we use maths.radians to convert degrees into radians.\n                # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxSetJointTargetPosition\n                print("Motors target positions: " + str(ashoulder) + " " + str(aelbow) + " " + str(awrist))\n                vrep.simxSetJointTargetPosition(clientID, wristHandle, math.radians(awrist), opmode)\n                vrep.simxSetJointTargetPosition(clientID, elbowHandle, math.radians(aelbow), opmode)\n                vrep.simxSetJointTargetPosition(clientID, shoulderHandle, math.radians(ashoulder), opmode)\n \n                # Wait in order to let the motors finish their movements\n                # Tip: there must be a more efficient way to do it...\n                time.sleep(5)\n \n                # Get the motors effective positions after the movement sequence\n                # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetJointPosition\n                pwrist = vrep.simxGetJointPosition(clientID, wristHandle, opmode)\n                pelbow = vrep.simxGetJointPosition(clientID, elbowHandle, opmode)\n                pshoulder = vrep.simxGetJointPosition(clientID, shoulderHandle, opmode)\n                print("Motors reached positions: " + str(ashoulder) + " " + str(aelbow) + " " + str(awrist))\n \n                # Get the robot position after the movement sequence\n                pret, robotPos = vrep.simxGetObjectPosition(clientID, robotHandle, -1, vrep.simx_opmode_buffer)\n                print("2w1a position: (x = " + str(robotPos[0]) +\\\n                      ", y = " + str(robotPos[1]) + ")")\n \n                # Get the robot orientation after the movement sequence\n                oret, robotOrient = vrep.simxGetObjectOrientation(clientID, robotHandle, -1, vrep.simx_opmode_buffer)\n                print("2w1a orientation: (x = " + str(robotOrient[0]) +\\\n                      ", y = " + str(robotOrient[1]) +\\\n                      ", z = " + str(robotOrient[2]) + ")")\n \n            # End the simulation, wait to be sure V-REP had the time to stop it entirely\n            # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxStopSimulation\n            vrep.simxStopSimulation(clientID, opmode)\n            time.sleep(1)\n            print("----- Simulation ended -----")\n \n    # Close the connection to V-REP remote server\n    # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxFinish\n    vrep.simxFinish(clientID)\nelse:\n    print (\'Failed connecting to remote API server\')\nprint (\'End\') \n 操作影片:  \n \n \n \n', 'tags': '', 'url': 'Week12.html'}, {'title': 'Week13', 'text': '帳號被Flagged \n 因為帳號名稱都是連號，所以被github誤判定為假帳號，導致沒辦法進行推送及協同同步網站的動作。 \n \n github support過程 :\xa0 \n \n Github account flagged 的解決方法: \n \n 寫信詢問為何會被封鎖, 並 尋求解除封鎖 . \n 自行建立 \xa0 gogs \xa0 與 \xa0 Fossil SCM \xa0 伺服器, 利用 gogs 展開原先在 Github 倉儲中的歷程資料, 利用 Fossil SCM 伺服原先在 Github Pages 上的靜態網頁 \n \n 開始線上遠距教學 \n 因應學校的遠距教學， 「嚴重特殊傳染性肺炎」疫情課程彈性處理事項_遠距教學公告_0515D(中英版本).pdf ,，線上同步上課採 OBS + Youtube 配合 \xa0 https://meet.google.com \xa0 直播方式進行。 \n 同步直播課程進行過程由指定各組員針對課程內容進行直播操作,，並將直播網址公布在 \xa0 https://gitter.im/mdecourse/cd2021 ，讓其他學員及老師進行互動。 \n obs載點 \n \n', 'tags': '', 'url': 'Week13.html'}, {'title': 'Week14', 'text': '\n 零件繪製 \n 經過商討零件尺寸及各個零件的結合後畫出下圖的停車塔，作動原理是由圖中黃色部分的馬達運轉並由皮帶帶動下方的主軸，並且主軸帶動鍊條讓車位能夠順時針、逆時針轉動，達到有效最大化的利用空間區域停放車輛。 \n 檔案連結 \n \n 講解影片 :\xa0 \n \n Coppeliasim 控制程式學習 \n \n Lua embedded scripts - 根據 官方簡介 與 \xa0 Tutorial , 在 網際解譯器 中執行, 並參考 \xa0 CAD2020 CoppeliaSim \xa0 頁面中的範例, 了解如何利用 non-threaded and threaded Lua 操控模擬場景中的機電系統。 \n Legacy Python remote API - 根據 簡介 , \xa0 客戶端需求說明 與 \xa0 Tutorial , 並參考 \xa0 CAD2020 CoppeliaSim \xa0 頁面中的範例, 查詢 \xa0 Python remote API 函式 , 了解如何利用 Python 操控模擬場景中的機電系統。 \n B0-based remote API - 根據 簡介 了解如何利用 Python 操控模擬場景中的機電系統。 \n 在 Python remote API 中導入 Flask, 並啟動 server 的多埠號架構, 將場景中的 image sensor 影像串流至各操控端瀏覽器, 以便執行組員間的場景協同控制系統設計。 \n \n \n \n', 'tags': '', 'url': 'Week14.html'}, {'title': 'Week15', 'text': 'Fossil \n 因為被標記期間無法推送至github，但一樣要有推送紀錄去評分，所以使用GOGS來當作一個推送的平台，如下圖。 \n \n \n 1. 先去 註冊 一個跟原先帳號一樣名稱的帳號。 \n 2. 創建一個跟原先倉儲一樣名稱的倉儲。 \n 3. 利用git remote add 指令。 \n \n RoboDK機械手臂 \n \n 自行利用 SolidWorks, Inventor, NX, Onshape 或 Solvespace 繪製機械手臂零組件後, 分別以 ASCII STL 或 Binary STL 手動轉入 Coppeliasim 建立機械手臂 .ttm 模型備用。 \n 根據 CoppeliaSim 4.1.0 版 (4.2.0 無法開啟 .simplescene.xml 檔案) 中的 \xa0 XML simplescene 格式 , 利用 Python 程式建立所需的機械手臂 .ttm 模型備用。 \n 根據 RoKiSim 中的六軸機械手臂定義, 以 Python 程式, 將既有的 Industrial Robots STL 轉為 CoppeliaSim simplexml 模型格式備用。 \n 將上述完成的機械手臂模型導入場景後, 機械手臂末端利用 force sensor 接上 components/grippers/suction pad.ttm tool 後, 先完成 MTB Robot 取放 Block 範例的改寫, 再完成 \xa0 FANUC M-710iC/50 \xa0 機械手臂的 圓球取放範例 。 \n \n 程式碼(pick and place.py檔) \n \n # KMOLab Portable RoboDK pick and place\nfrom robolink import *    # API to communicate with robodk\nfrom robodk import *      # robodk robotics toolbox\n \n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n \n#----------------------------------------------\n# Function definitions\n \ndef box_calc(BALLS_SIDE=4, BALLS_MAX=None):\n    """Calculate a list of points (ball center) as if the balls were stored in a box"""\n    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3\n    xyz_list = []\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE):\n            for j in range(BALLS_SIDE):\n                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]\n                if len(xyz_list) >= BALLS_MAX:\n                    return xyz_list\n    return xyz_list\n \ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n \ndef balls_setup(frame, positions):\n    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""\n    nballs = len(positions)\n    step = 1.0/(nballs - 1)\n    for i in range(nballs):\n        newball = frame.Paste()\n        newball.setName(\'ball \' + str(i)) #set item name\n        newball.setPose(transl(positions[i])) #set item position with respect to parent\n        newball.setVisible(True, False) #make item visible but hide the reference frame\n        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color\n \ndef cleanup_balls(parentnodes):\n    """Delete all child items whose name starts with \\"ball\\", from the provided list of parent items."""\n    todelete = []\n    for item in parentnodes:\n        todelete = todelete + item.Childs()\n \n    for item in todelete:\n        if item.Name().startswith(\'ball\'):\n            item.Delete()\n \ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n         \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n \n \n#----------------------------------------------------------\n# The program starts here:\n \n# Any interaction with RoboDK must be done through RDK:\nRDK = Robolink()\n \n# Turn off automatic rendering (faster)\nRDK.Render(False)\n \n#RDK.Set_Simulation_Speed(500); # set the simulation speed\n \n# Gather required items from the station tree\nrobot = RDK.Item(\'Fanuc M-710iC/50\')\nrobot_tools = robot.Childs()\n#robottool = RDK.Item(\'MainTool\')\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n \n# Copy a ball as an object (same as CTRL+C)\nballref = RDK.Item(\'reference ball\')\nballref.Copy()\n \n# Run a pre-defined station program (in RoboDK) to replace the two tables\nprog_reset = RDK.Item(\'Replace objects\')\nprog_reset.RunProgram()\n \n# Call custom procedure to remove old objects\ncleanup_balls([frame1, frame2])\n \n# Make a list of positions to place the objects\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n \n# Programmatically place the objects with a custom-made procedure\nballs_setup(frame1, frame1_list)\n \n# Delete previously generated tools\nfor tool in robot_tools:\n    if tool.Name().startswith(\'TCP\'):\n        tool.Delete()\n         \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n \nTCP_0 = TCP_list[0]\n \n# Turn on automatic rendering\nRDK.Render(True)\n \n# Move balls    \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n \nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n \n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n \n    # grab ntake balls from frame 1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1       \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n  \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame 2 and place the tool balls into table 2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n         \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1       \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n \n    robot.MoveJ(target_app_frame)\n \n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200]) \n \n 操作影片 :\xa0 \n \n', 'tags': '', 'url': 'Week15.html'}, {'title': 'Week16', 'text': 'MTB_robot 取放方塊流程 \n 1. Onshape 零組件繪製 \n 利用onshape軟體參考 \xa0 MTB_robot \xa0並繪製出一個組件相似的mtb_robot。 \n 圖檔連結 :\xa0 \n https://cad.onshape.com/documents/32cde3f6802dd89685eddff5/w/76107044dbe1d78bc3ff0d6b/e/1b23389c5ce43ea5d81a4977 \n 操作影片 :\xa0 \n \n \n 2. 建立 CoppeliaSim 4.1.0 MTB robot 場景 \xa0 \n 將組合好的MTB_模型以stl檔匯出之後匯入coppeliasim裡，並利用Leo Editer以require導入lua程式運作，分別控制各軸轉動。 \n Google Drive: https://drive.google.com/file/d/1Ppl7lwSd5PQIdc0V-gI1-slmAlB7n5l2/view?usp=sharing \n 程式碼需要參考可以下載上面連結裡的lua檔案 \n if (auxiliaryData[1]==49) then --r right turn in degree\n                    -- if key 1 pressed axis1 angle adds 5 degrees\n                     rotation1 = rotation1 + 5*deg\n                     sim.setJointPosition(axis1, rotation1)\n                end -- if 1\nif (auxiliaryData[1]==50) then --l left turn in degree\n                    -- if key 2 pressed axis1 angle substract 5 degrees\n                     rotation1 = rotation1 - 5*deg\n                     sim.setJointPosition(axis1, rotation1)\n                end -- if 2\nif (auxiliaryData[1]==52) then --l left1 turn in degree\n                    -- if key 4 pressed axis1 angle substract 5 degrees\n                     rotation2 = rotation2 + 5*deg\n                     sim.setJointPosition(axis2, rotation2)\n                end -- if 4\nif (auxiliaryData[1]==53) then --r left2 turn in degree\n                    -- if key 5 pressed axis1 angle substract 5 degrees\n                     rotation2 = rotation2 - 5*deg\n                     sim.setJointPosition(axis2, rotation2) \n 上方程式碼是這個取分項目的重點，==後的數字是分別代表 鍵盤的代碼 ，我的是使用數字1、2來操控大軸，數字4、5來操控小軸。 \n 操作影片 :\xa0 \n \n 3. 手臂末端加入 components-gripper-suction pad 吸盤 \n 接續上一個取分項目使用的MTB_robot，在繪製的吸盤零件末端加上一個force sensor並接上suction pad。 \n Google Drive: https://drive.google.com/file/d/1joVVPnSevFK1cdNXeTmb-A3iSABC1DS4/view?usp=sharing \n 程式碼一樣可以參考上方連結的lua檔，下方圖片是比較需要調整的參數，calibration是校正的參數，因為吸盤離太進或離太遠都會沒辦法讓dummy附著到cuboid上，所以要慢慢找適合自己組合圖的參數。 \n \n function sysCall_actuation() \n    calibration = 0.002 \n \n 然後要把吸盤的user parameters的active的value加上true，這樣吸盤靠近方塊時就能自動吸取了。 \n \n \n 操作影片 :\xa0 \n \n 4. 逆向運動學函式 \xa0 \n 根據 W15 線上課程內容之 Inverse Kinematics 方程式，用程式指定方塊取放兩個位置，分別是 (0.2, 0.7, 0.05) 與 (-0.3, -0.55, 0.05)，一樣可以接續之前的ttt檔做更改使用。 \n Google Drive: https://drive.google.com/file/d/1CEOEhOYhh9_C5nQH3Gul1xo2tbp8I7GZ/view?usp=sharing \n 要注意的是要將joint的扭矩設為2.5e+9，不然跑程式時會瘋狂亂轉。 \n \n \n 操作影片:\xa0 \n \n 5. Python remote API 逆向運動學函式 \xa0 \n 這個取分項目是結合Task2所學的Python remote API 程式並以迴圈方式執行兩個指定位置之方塊取放。 \n Google Drive: https://drive.google.com/file/d/1hczjw-DDXETi1h2k4MT0J5OMmPVLLp3T/view?usp=sharing \n 要注意的是要在資料夾下新增remoteApi.dll，sim.py,simConst.py,math.py這幾個檔案，這樣在Go的時候才能夠順利connect到remote api。 \n \n \n 操作影片 :\xa0 \n \n 五個取分項目皆在期限內完成，自評完成度100% \n', 'tags': '', 'url': 'Week16.html'}, {'title': 'Week17', 'text': 'Week18 \n', 'tags': '', 'url': 'Week17.html'}, {'title': 'Experience', 'text': 'Week1 \n 開始了協同產品設計的第一週，說起來也慚愧，畢竟是之前太混什麼都沒學到才被當的，這學期會認真學習的。 \n 一開始一如往常地建立個人倉儲，這次不一樣的事是直接使用現成的子模組，比起以前方扁許多，然後薛席從英文單字了解其中的意義，像collaborative,product,design等等，最後就是編輯自己的leo editer，雖然有點落後進度不過會努力跟上的。 \n \n Week2 \n 跟以前不一樣的是，這次分組不再是使用亂數分組，而是使用Ethercalc的協同同步方式，我覺得是很有效率的方法，不過也出現了些小問題。 \n 然後就是開始著手製作第一次的專題題目，但本身對coppeliasim不熟，所以還需要些時間摸索。 \n \n Week3 \n 這週都在繪製零件跟操作coppeliasim，還有建立ssh對自己的github連線，我覺得要理解ssh蠻難的，不過還是有順利連線，上課中還有遇到個問題就是，分組網站不是建立在組長下面，所以就學習了如何使用git remote add並推送至各自的倉儲下，回家後就繼續測試並且製作下週報告要用的html與pdf。 \n \n Week4 \n 如果只是單純的直線路徑並不是一個好的作品，要加入考量迴轉半徑、離心力、輪子收縮、物體加入質量、需要多大馬力起飛、加入感測器等等各種參數，當初選定題目時沒有考量那麼多，還有要有設計流程圖，很多問題都是當初沒有想到的，幸虧有老師的點醒。 \n Week5 \n 這週開始了第二次的分組專案，我這次就不是跟第一次分組的組員了，經過了討論許久後，我們雙方都不延續之前的主題，一個因為沒什麼發展空間，一個因為要延續的話太難，所以決定做變速箱，國內沒什麼資料或設計參考圖，所以我們也找了很多國外的資料。 \n Week6 \n 這週我開始畫幾個構想的機構圖，然後參照國外網站找到的變速箱原型下去繪製零件與組合，在模數與齒比和零件尺寸的設計上花了很多時間，在網站的協同上也因為比第一次分組時多了兩個人，所以也面臨了許多新的協同問題，還好組員們很給力也一一的解決問題了。 \n Week7 \n 這週成功讓機構在coppeliasim作動了，一開始丟進去發現拆解後有上百個零組件時我們就先抑制掉大部分零件後先是試著讓其作動，但也發生了問題，我們也只能嘗試著各種排列組合去排列從屬關係，最後有成工作動了，但某些零件做動不太合理。 \n Week8 \n 這週我們開始嘗試讓排檔桿做動，但是在設置dummy跟設置IE關節時遇到了很多問題，但時間的關係所以只能省略很多零件以及加緊腳步了，開始製作簡報與PDF，畢竟下禮拜要報告了。 \n Week9 \n 這週是我們的報告週，也是這學期的期中考週，雖然我們在coppeliasim裡面沒有成功的讓機構相互作動起來，雖然知道該往哪個方向去改進，但因為時間不足所以只能先製作報告了，希望下次專題能更快完成自己分工的任務。 \n Week10 \n 這週我們開始了第三次的分組專題，這次的人數直接跳到了八個人一組，想必在統整想法及協同網站時會遇到更多的困難，不過相信會一步一步的解決的。 \n Week11 \n 這週開始制定主題，然後 先瞭解各個組員是否會使用SSH等一些基本的東西，並且建立好分組網站及確認組員都熟悉協同方式。 \n Week12 \n 最後選定題目為停車塔，並且不延續各自組別stage-ag1,stage-ag2的題目，要馬是不好發揮或是沒有什麼特色，等組長制定好完成日期後就要開始加速動工了，採用的是每人都畫看看最後再投票決定要使用哪個，這樣在後續組裝比較不會有干涉問題，且讓每個人都有各自的發揮空間。 \n Week13 \n 由於疫情逐漸加重的關係，開始採用google meeting的方式線上直播教學，這週我們先是開一個新的會議各自討論，並且讓組員們各自show自己所繪製的組合圖/零件，這個方式比起在教室大家跑來跑去各自的電腦看還要有效率，並且也能讓每個組員都能確實參與到開會內。。 \n Week14 \n 這週我們先將其中一個組員繪製的停車塔放進coppeliasim裡面模擬，先是加進Revolute joint、Prismatic joint跟設好Target velocity而已，並且將物體的dynamic打開，目前就是能夠讓底座上升及讓外殼旋轉讓車子能順利抵達樓上的停車位而已，尚有許多地方要改良。 \n Week15 \n 這週上的是 Lua embedded scripts及Python remote API，比較難理解一點，但也有成功完成老師的robotDK的作業，而分組網站 這週我們將各個部位加上老師上課所教的Lua scipt，並加入message_keypress的程式碼讓各部位能夠用相對應的鍵盤作動，最後在組長的幫忙下也是能如預期地作動了。 \n Week16 \n 這週github帳戶好不容易解除flagged了，能恢復之前的協同方式了，這週老師指派了一個MTB_robot的取分項目，流程大概就是從onshape繪圖到放進coppeliasim做動都要由自己完成，雖然一 開始也是卡了很久，但花時間去看了各種國外網站教學後也是順利完成了100%。 \n Week17 \n Week18 \n', 'tags': '', 'url': 'Experience.html'}]};